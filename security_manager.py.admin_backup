"""
Security Manager for R3ÆLƎR AI
Comprehensive security with authentication, encryption, and threat detection
"""

import logging
import hashlib
import hmac
import secrets
import time
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import json
import os

logger = logging.getLogger(__name__)

class SecurityManager:
    """
    Comprehensive security management for the AI system
    """

    def __init__(self):
        self.encryption_key = self._load_or_generate_key()
        self.active_sessions = {}
        self.threat_patterns = {}
        self.rate_limits = {}

        # Security settings
        self.max_requests_per_minute = 60
        self.session_timeout = 3600  # 1 hour
        self.max_failed_attempts = 5

        logger.info("Security manager initialized")

    def _load_or_generate_key(self) -> bytes:
        """Load or generate encryption key"""
        key_file = os.path.join(os.path.dirname(__file__), 'security_key.bin')

        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            # Generate new key
            key = secrets.token_bytes(32)
            with open(key_file, 'wb') as f:
                f.write(key)
            return key

    def validate_request(self, query: str, user_id: str) -> bool:
        """Validate incoming request for security threats"""

        # Rate limiting check
        if not self._check_rate_limit(user_id):
            logger.warning(f"Rate limit exceeded for user: {user_id}")
            return False

        # Content security check
        if not self._check_content_security(query):
            logger.warning(f"Content security violation for user: {user_id}")
            return False

        # Threat pattern detection
        if self._detect_threats(query):
            logger.warning(f"Threat pattern detected for user: {user_id}")
            return False

        return True

    def _check_rate_limit(self, user_id: str) -> bool:
        """Check if user is within rate limits"""
        current_time = time.time()
        window_start = current_time - 60  # 1 minute window

        if user_id not in self.rate_limits:
            self.rate_limits[user_id] = []

        # Clean old requests
        self.rate_limits[user_id] = [
            req_time for req_time in self.rate_limits[user_id]
            if req_time > window_start
        ]

        # Check limit
        if len(self.rate_limits[user_id]) >= self.max_requests_per_minute:
            return False

        # Add current request
        self.rate_limits[user_id].append(current_time)
        return True

    def _check_content_security(self, query: str) -> bool:
        """Check query content for security violations"""

        # List of blocked patterns
        blocked_patterns = [
            r'<script',  # XSS attempts
            r'javascript:',  # JavaScript injection
            r'union.*select',  # SQL injection
            r'drop.*table',  # SQL injection
            r'--',  # SQL comments
            r'/\*.*\*/',  # SQL comments
        ]

        query_lower = query.lower()

        for pattern in blocked_patterns:
            import re
            if re.search(pattern, query_lower, re.IGNORECASE):
                return False

        # Check for excessive special characters
        special_chars = sum(1 for c in query if not c.isalnum() and not c.isspace())
        if special_chars > len(query) * 0.3:  # More than 30% special chars
            return False

        return True

    def _detect_threats(self, query: str) -> bool:
        """Detect potential threat patterns"""

        threat_indicators = [
            'password', 'admin', 'root', 'sudo',
            'exploit', 'vulnerability', 'hack',
            'malware', 'virus', 'trojan',
            'attack', 'breach', 'compromise'
        ]

        query_lower = query.lower()

        # Count threat indicators
        threat_count = sum(1 for indicator in threat_indicators if indicator in query_lower)

        # Flag if too many threat indicators
        return threat_count > 2

    def create_session(self, user_id: str) -> str:
        """Create a new secure session"""

        session_id = secrets.token_hex(32)
        session_data = {
            'user_id': user_id,
            'created': datetime.now(),
            'last_activity': datetime.now(),
            'failed_attempts': 0
        }

        self.active_sessions[session_id] = session_data
        logger.info(f"Session created for user: {user_id}")

        return session_id

    def validate_session(self, session_id: str) -> bool:
        """Validate session and update activity"""

        if session_id not in self.active_sessions:
            return False

        session = self.active_sessions[session_id]

        # Check timeout
        if datetime.now() - session['last_activity'] > timedelta(seconds=self.session_timeout):
            del self.active_sessions[session_id]
            return False

        # Update activity
        session['last_activity'] = datetime.now()

        return True

    def encrypt_data(self, data: str) -> str:
        """Encrypt sensitive data"""
        try:
            import cryptography
            from cryptography.fernet import Fernet

            fernet = Fernet(self.encryption_key)
            encrypted = fernet.encrypt(data.encode())
            return encrypted.decode()

        except ImportError:
            # Fallback to simple obfuscation if cryptography not available
            logger.warning("Cryptography library not available, using simple obfuscation")
            return self._simple_obfuscate(data)

    def decrypt_data(self, encrypted_data: str) -> str:
        """Decrypt sensitive data"""
        try:
            import cryptography
            from cryptography.fernet import Fernet

            fernet = Fernet(self.encryption_key)
            decrypted = fernet.decrypt(encrypted_data.encode())
            return decrypted.decode()

        except ImportError:
            # Fallback to simple deobfuscation
            return self._simple_deobfuscate(encrypted_data)

    def _simple_obfuscate(self, data: str) -> str:
        """Simple obfuscation fallback"""
        # This is NOT secure - just for demonstration
        return ''.join(chr(ord(c) + 1) for c in data)

    def _simple_deobfuscate(self, data: str) -> str:
        """Simple deobfuscation fallback"""
        return ''.join(chr(ord(c) - 1) for c in data)

    def generate_api_key(self, user_id: str) -> str:
        """Generate API key for user"""
        timestamp = str(int(time.time()))
        random_component = secrets.token_hex(16)

        # Create HMAC-based key
        message = f"{user_id}:{timestamp}:{random_component}"
        signature = hmac.new(
            self.encryption_key,
            message.encode(),
            hashlib.sha256
        ).hexdigest()

        api_key = f"{user_id}.{timestamp}.{random_component}.{signature[:16]}"
        return api_key

    def validate_api_key(self, api_key: str) -> Optional[str]:
        """Validate API key and return user_id"""
        try:
            parts = api_key.split('.')
            if len(parts) != 4:
                return None

            user_id, timestamp, random_component, signature_part = parts

            # Basic validation (would be more thorough in production)
            if len(signature_part) != 16:
                return None

            # Check timestamp not too old (24 hours)
            if time.time() - int(timestamp) > 86400:
                return None

            return user_id

        except Exception as e:
            logger.error(f"API key validation error: {e}")
            return None

    def log_security_event(self, event_type: str, user_id: str, details: Dict):
        """Log security-related events"""
        event = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'user_id': user_id,
            'details': details
        }

        logger.info(f"Security event: {event_type} for user {user_id}")

        # In production, this would write to a secure log file or database
        # For now, just log to console

    def get_security_status(self) -> Dict[str, Any]:
        """Get current security status"""
        return {
            "active_sessions": len(self.active_sessions),
            "rate_limits_active": len(self.rate_limits),
            "threat_patterns": len(self.threat_patterns),
            "encryption_enabled": True,
            "status": "active"
        }

    def cleanup_expired_sessions(self):
        """Clean up expired sessions"""
        current_time = datetime.now()
        expired_sessions = []

        for session_id, session_data in self.active_sessions.items():
            if current_time - session_data['last_activity'] > timedelta(seconds=self.session_timeout):
                expired_sessions.append(session_id)

        for session_id in expired_sessions:
            del self.active_sessions[session_id]

        if expired_sessions:
            logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")

    def optimize(self):
        """Optimize security systems"""
        logger.info("Optimizing security systems...")

        # Cleanup expired sessions
        self.cleanup_expired_sessions()

        # Clear old rate limit data
        current_time = time.time()
        old_window = current_time - 3600  # 1 hour ago

        for user_id in list(self.rate_limits.keys()):
            self.rate_limits[user_id] = [
                req_time for req_time in self.rate_limits[user_id]
                if req_time > old_window
            ]

            # Remove users with no recent activity
            if not self.rate_limits[user_id]:
                del self.rate_limits[user_id]

        logger.info("Security optimization completed")

    def get_status(self) -> Dict[str, Any]:
        """Get security manager status"""
        return {
            "component": "SecurityManager",
            **self.get_security_status()
        }